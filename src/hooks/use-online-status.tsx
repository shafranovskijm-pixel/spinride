import { useState, useEffect, useCallback } from 'react';
import { getSyncQueue, removeFromSyncQueue, incrementSyncRetry } from '@/lib/offline-db';
import { supabase } from '@/integrations/supabase/client';
import { toast } from 'sonner';

export function useOnlineStatus() {
  const [isOnline, setIsOnline] = useState(() => 
    typeof navigator !== 'undefined' ? navigator.onLine : true
  );
  const [isSyncing, setIsSyncing] = useState(false);
  const [pendingCount, setPendingCount] = useState(0);

  // Update pending count
  const updatePendingCount = useCallback(async () => {
    try {
      const queue = await getSyncQueue();
      setPendingCount(queue.length);
    } catch {
      // IndexedDB might not be available
    }
  }, []);

  // Process sync queue
  const processQueue = useCallback(async () => {
    if (!isOnline || isSyncing) return;
    
    setIsSyncing(true);
    const queue = await getSyncQueue();
    
    if (queue.length === 0) {
      setIsSyncing(false);
      return;
    }

    let successCount = 0;
    let failCount = 0;

    for (const item of queue) {
      if (item.retries >= 3) {
        // Remove items that failed too many times
        await removeFromSyncQueue(item.id!);
        failCount++;
        continue;
      }

      try {
        // Process based on type
        switch (item.type) {
          case 'favorite':
            await processFavoriteSync(item);
            break;
          case 'order':
            await processOrderSync(item);
            break;
          // Cart is local-only, no sync needed
        }
        
        await removeFromSyncQueue(item.id!);
        successCount++;
      } catch (error) {
        console.error('Sync error:', error);
        await incrementSyncRetry(item.id!);
        failCount++;
      }
    }

    if (successCount > 0) {
      toast.success(`Синхронизировано: ${successCount} действий`);
    }
    if (failCount > 0) {
      toast.error(`Не удалось синхронизировать: ${failCount} действий`);
    }

    await updatePendingCount();
    setIsSyncing(false);
  }, [isOnline, isSyncing, updatePendingCount]);

  useEffect(() => {
    const handleOnline = () => {
      setIsOnline(true);
      toast.success('Подключение восстановлено', {
        description: 'Синхронизация данных...',
      });
      // Process queue when coming online
      setTimeout(processQueue, 1000);
    };

    const handleOffline = () => {
      setIsOnline(false);
      toast.warning('Офлайн-режим', {
        description: 'Изменения будут синхронизированы при восстановлении сети',
      });
    };

    window.addEventListener('online', handleOnline);
    window.addEventListener('offline', handleOffline);

    // Initial pending count
    updatePendingCount();

    return () => {
      window.removeEventListener('online', handleOnline);
      window.removeEventListener('offline', handleOffline);
    };
  }, [processQueue, updatePendingCount]);

  return {
    isOnline,
    isSyncing,
    pendingCount,
    processQueue,
    updatePendingCount,
  };
}

// Sync processors
async function processFavoriteSync(item: { action: string; data: unknown }) {
  const data = item.data as { productId: string; userId: string };
  
  if (item.action === 'add') {
    await supabase.from('favorites').insert({
      product_id: data.productId,
      user_id: data.userId,
    });
  } else if (item.action === 'remove') {
    await supabase.from('favorites').delete()
      .eq('product_id', data.productId)
      .eq('user_id', data.userId);
  }
}

async function processOrderSync(item: { action: string; data: unknown }) {
  if (item.action === 'create') {
    const orderData = item.data as {
      customer_name: string;
      customer_phone: string;
      customer_email?: string;
      delivery_method: string;
      delivery_address?: string;
      notes?: string;
      items: unknown;
      total_amount: number;
    };
    
    // order_number is required by types but auto-generated by trigger
    const tempOrderNumber = `SR-SYNC-${Date.now()}-${Math.random().toString(36).slice(2, 6)}`;
    await supabase.from('orders').insert([{
      order_number: tempOrderNumber,
      customer_name: orderData.customer_name,
      customer_phone: orderData.customer_phone,
      customer_email: orderData.customer_email,
      delivery_method: orderData.delivery_method,
      delivery_address: orderData.delivery_address,
      notes: orderData.notes,
      items: orderData.items as import('@/integrations/supabase/types').Json,
      total_amount: orderData.total_amount,
    }]);
  }
}
